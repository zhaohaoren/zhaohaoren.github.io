<!DOCTYPE html><html><head><title>掘金</title><meta name="referrer" content="no-referrer"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><h2>掘金</h2><p><a href="https://juejin.cn/user/2814346130104173">掘金主页</a>  | 文章总数：{}</p>
<h4 id="Maven必知必会-settings文件解析（2021-11-30-00-26-59-阅读-606-评论-0）"><a href="#Maven必知必会-settings文件解析（2021-11-30-00-26-59-阅读-606-评论-0）" class="headerlink" title="Maven必知必会 - settings文件解析（2021-11-30 00:26:59 | 阅读 606 | 评论 0）"></a><a href="https://juejin.cn/post/7036027955524403207">Maven必知必会 - settings文件解析</a>（2021-11-30 00:26:59 | 阅读 606 | 评论 0）</h4><p>这是我参与11月更文挑战的第28天，活动详情查看：2021最后一次更文挑战 Maven必知必会 - settings文件解析 刚入职一个新公司的时候，很多时候我们需要和老员工要这么个settings文</p>
<h4 id="Maven必知必会-仓库（2021-11-29-22-59-40-阅读-130-评论-0）"><a href="#Maven必知必会-仓库（2021-11-29-22-59-40-阅读-130-评论-0）" class="headerlink" title="Maven必知必会 - 仓库（2021-11-29 22:59:40 | 阅读 130 | 评论 0）"></a><a href="https://juejin.cn/post/7036006609125900325">Maven必知必会 - 仓库</a>（2021-11-29 22:59:40 | 阅读 130 | 评论 0）</h4><p>这是我参与11月更文挑战的第27天，活动详情查看：2021最后一次更文挑战 Maven必知必会 - 仓库 Maven这个工具基本做Java的都会用，但是一些相关的基础概念反而成为一个容易被大家忽视的东</p>
<h4 id="Spring-AOP之-AspectJ注解（2021-11-28-23-50-44-阅读-1342-评论-0）"><a href="#Spring-AOP之-AspectJ注解（2021-11-28-23-50-44-阅读-1342-评论-0）" class="headerlink" title="Spring AOP之@AspectJ注解（2021-11-28 23:50:44 | 阅读 1342 | 评论 0）"></a><a href="https://juejin.cn/post/7035648108486721544">Spring AOP之@AspectJ注解</a>（2021-11-28 23:50:44 | 阅读 1342 | 评论 0）</h4><p>这是我参与11月更文挑战的第26天，活动详情查看：2021最后一次更文挑战 Spring AOP之@AspectJ注解 Spring2.0之后发布的新的特性： @AspectJ注解到POJO来定义As</p>
<h4 id="Spring-ApplicationContext的一些功能笔记（2021-11-27-23-58-44-阅读-127-评论-0）"><a href="#Spring-ApplicationContext的一些功能笔记（2021-11-27-23-58-44-阅读-127-评论-0）" class="headerlink" title=" Spring-ApplicationContext的一些功能笔记（2021-11-27 23:58:44 | 阅读 127 | 评论 0）"></a><a href="https://juejin.cn/post/7035279472022519822"> Spring-ApplicationContext的一些功能笔记</a>（2021-11-27 23:58:44 | 阅读 127 | 评论 0）</h4><p>这是我参与11月更文挑战的第25天，活动详情查看：2021最后一次更文挑战 ApplicationContext除了拥有 BeanFactory支持的所有功能之外，还进一步扩展了基本容器的功能。包括B</p>
<h4 id="异常-断言-日志（2021-11-26-23-59-23-阅读-378-评论-0）"><a href="#异常-断言-日志（2021-11-26-23-59-23-阅读-378-评论-0）" class="headerlink" title="异常 - 断言 - 日志（2021-11-26 23:59:23 | 阅读 378 | 评论 0）"></a><a href="https://juejin.cn/post/7034908476677554184">异常 - 断言 - 日志</a>（2021-11-26 23:59:23 | 阅读 378 | 评论 0）</h4><p>这是我参与11月更文挑战的第24天，活动详情查看：2021最后一次更文挑战 异常 Error 和 Exception下面的RunTimeException及其子类属于不需要强制补货的异常。 其他 ex</p>
<h4 id="Redis中过期的key删除策略（2021-11-25-22-54-23-阅读-200-评论-0）"><a href="#Redis中过期的key删除策略（2021-11-25-22-54-23-阅读-200-评论-0）" class="headerlink" title="Redis中过期的key删除策略（2021-11-25 22:54:23 | 阅读 200 | 评论 0）"></a><a href="https://juejin.cn/post/7034521019318534175">Redis中过期的key删除策略</a>（2021-11-25 22:54:23 | 阅读 200 | 评论 0）</h4><p>这是我参与11月更文挑战的第23天，活动详情查看：2021最后一次更文挑战 一个Redis面试常见的面试题目：Redis中如果一个键过期了，那么它什么时候会被删除呢? 采用了什么策略呢？ 一般策略 首</p>
<h4 id="数仓数据各层概念（2021-11-24-23-51-47-阅读-137-评论-0）"><a href="#数仓数据各层概念（2021-11-24-23-51-47-阅读-137-评论-0）" class="headerlink" title="数仓数据各层概念（2021-11-24 23:51:47 | 阅读 137 | 评论 0）"></a><a href="https://juejin.cn/post/7034164289216872484">数仓数据各层概念</a>（2021-11-24 23:51:47 | 阅读 137 | 评论 0）</h4><p>这是我参与11月更文挑战的第22天，活动详情查看：2021最后一次更文挑战 数仓在建设中在数据处理的流程中一般都会分为多个数据层次。这样可以让我们在数据的处理中，可以更加清晰数据的加工流程，并且分层也</p>
<h4 id="Hadoop-Pseudo-Distributed-Operation-伪分布式模式（2021-11-23-23-51-14-阅读-100-评论-0）"><a href="#Hadoop-Pseudo-Distributed-Operation-伪分布式模式（2021-11-23-23-51-14-阅读-100-评论-0）" class="headerlink" title="Hadoop Pseudo-Distributed Operation 伪分布式模式（2021-11-23 23:51:14 | 阅读 100 | 评论 0）"></a><a href="https://juejin.cn/post/7033793314373664805">Hadoop Pseudo-Distributed Operation 伪分布式模式</a>（2021-11-23 23:51:14 | 阅读 100 | 评论 0）</h4><p>这是我参与11月更文挑战的第21天，活动详情查看：2021最后一次更文挑战 Pseudo-Distributed Operation 伪分布式模式 单机上搭建一个集群的方式。 配置 1. 配置脚本ha</p>
<h4 id="Elasticsearch的Mapping使用说明（2021-11-22-23-09-20-阅读-158-评论-0）"><a href="#Elasticsearch的Mapping使用说明（2021-11-22-23-09-20-阅读-158-评论-0）" class="headerlink" title="Elasticsearch的Mapping使用说明（2021-11-22 23:09:20 | 阅读 158 | 评论 0）"></a><a href="https://juejin.cn/post/7033411448386945037">Elasticsearch的Mapping使用说明</a>（2021-11-22 23:09:20 | 阅读 158 | 评论 0）</h4><p>这是我参与11月更文挑战的第20天，活动详情查看：2021最后一次更文挑战 text 会被分词，然后构建倒排。 不用于排序，很少用于聚合。 keyword 不会被分词 用于过滤。 Numeric da</p>
<h4 id="HDFS简介（2021-11-21-23-42-00-阅读-155-评论-0）"><a href="#HDFS简介（2021-11-21-23-42-00-阅读-155-评论-0）" class="headerlink" title="HDFS简介（2021-11-21 23:42:00 | 阅读 155 | 评论 0）"></a><a href="https://juejin.cn/post/7033048882619613191">HDFS简介</a>（2021-11-21 23:42:00 | 阅读 155 | 评论 0）</h4><p>这是我参与11月更文挑战的第19天，活动详情查看：2021最后一次更文挑战 HDFS是一个分布式的文件系统； 使用场景 适合一次写入，多次读出的场景，不支持文件的修改。适合用来数据分析，而不是做网盘程</p>
<h4 id="Java反射（2021-11-20-23-53-00-阅读-294-评论-0）"><a href="#Java反射（2021-11-20-23-53-00-阅读-294-评论-0）" class="headerlink" title="Java反射（2021-11-20 23:53:00 | 阅读 294 | 评论 0）"></a><a href="https://juejin.cn/post/7032680435079446558">Java反射</a>（2021-11-20 23:53:00 | 阅读 294 | 评论 0）</h4><p>这是我参与11月更文挑战的第18天，活动详情查看：2021最后一次更文挑战 什么是反射 Java中class和interface的数据类型都是class类型，每加载一个class，JVM就为其创建一个</p>
<h4 id="Mybatis缓存（2021-11-19-23-43-31-阅读-293-评论-0）"><a href="#Mybatis缓存（2021-11-19-23-43-31-阅读-293-评论-0）" class="headerlink" title="Mybatis缓存（2021-11-19 23:43:31 | 阅读 293 | 评论 0）"></a><a href="https://juejin.cn/post/7032306787202105381">Mybatis缓存</a>（2021-11-19 23:43:31 | 阅读 293 | 评论 0）</h4><p>这是我参与11月更文挑战的第17天，活动详情查看：2021最后一次更文挑战 一级缓存指的就是sqlsession，在sqlsession中有一个数据区域，是map结构，这个区域就是一级缓存区域。 一级</p>
<h4 id="kafka消费者（2021-11-18-10-20-25-阅读-355-评论-0）"><a href="#kafka消费者（2021-11-18-10-20-25-阅读-355-评论-0）" class="headerlink" title="kafka消费者（2021-11-18 10:20:25 | 阅读 355 | 评论 0）"></a><a href="https://juejin.cn/post/7031728905333506062">kafka消费者</a>（2021-11-18 10:20:25 | 阅读 355 | 评论 0）</h4><p>这是我参与11月更文挑战的第16天，活动详情查看：2021最后一次更文挑战 kafka消费者 Kafka消费者相关的概念 消费者与消费组 一个分区，只能被一个组内的一个消费者消费。不能多个消费者共同消</p>
<h4 id="Kafka生产者（2021-11-17-10-22-58-阅读-221-评论-0）"><a href="#Kafka生产者（2021-11-17-10-22-58-阅读-221-评论-0）" class="headerlink" title="Kafka生产者（2021-11-17 10:22:58 | 阅读 221 | 评论 0）"></a><a href="https://juejin.cn/post/7031358245755158564">Kafka生产者</a>（2021-11-17 10:22:58 | 阅读 221 | 评论 0）</h4><p>这是我参与11月更文挑战的第15天，活动详情查看：2021最后一次更文挑战 Kafka生产者 kafka的所有消息是遵循一定结构的，对应着Java的类就是ProducerRecord这个类： 其中：t</p>
<h4 id="Kafka安装（2021-11-16-10-08-32-阅读-129-评论-0）"><a href="#Kafka安装（2021-11-16-10-08-32-阅读-129-评论-0）" class="headerlink" title="Kafka安装（2021-11-16 10:08:32 | 阅读 129 | 评论 0）"></a><a href="https://juejin.cn/post/7030983829925920804">Kafka安装</a>（2021-11-16 10:08:32 | 阅读 129 | 评论 0）</h4><p>这是我参与11月更文挑战的第14天，活动详情查看：2021最后一次更文挑战 Kafka在以前的版本中，安装是需要依赖ZK的（早期版本的kafka用zk做meta元数据信息存储，consumer的消费状</p>
<h4 id="Kafka重要概念（2021-11-15-23-46-00-阅读-192-评论-0）"><a href="#Kafka重要概念（2021-11-15-23-46-00-阅读-192-评论-0）" class="headerlink" title="Kafka重要概念（2021-11-15 23:46:00 | 阅读 192 | 评论 0）"></a><a href="https://juejin.cn/post/7030823327845318687">Kafka重要概念</a>（2021-11-15 23:46:00 | 阅读 192 | 评论 0）</h4><p>这是我参与11月更文挑战的第13天，活动详情查看：2021最后一次更文挑战 Kafka的大概架构图如下： 主要角色 Producer：消息的生产者，可以有多个 Consumer：消息的消费者，可以有多</p>
<h4 id="mysql常见存储引擎（2021-11-14-23-58-16-阅读-372-评论-0）"><a href="#mysql常见存储引擎（2021-11-14-23-58-16-阅读-372-评论-0）" class="headerlink" title="mysql常见存储引擎（2021-11-14 23:58:16 | 阅读 372 | 评论 0）"></a><a href="https://juejin.cn/post/7030455312519790606">mysql常见存储引擎</a>（2021-11-14 23:58:16 | 阅读 372 | 评论 0）</h4><p>这是我参与11月更文挑战的第12天，活动详情查看：2021最后一次更文挑战 InnoDB Innodb只有一个文件，所以只能按照主键来组织索引的。他不需要MYISAM那样 数据一个文件，索引一个文件。</p>
<h4 id="ASM开发（2021-11-13-23-57-56-阅读-52-评论-0）"><a href="#ASM开发（2021-11-13-23-57-56-阅读-52-评论-0）" class="headerlink" title="ASM开发（2021-11-13 23:57:56 | 阅读 52 | 评论 0）"></a><a href="https://juejin.cn/post/7030084073410428964">ASM开发</a>（2021-11-13 23:57:56 | 阅读 52 | 评论 0）</h4><p>这是我参与11月更文挑战的第11天，活动详情查看：2021最后一次更文挑战 ASM就是自己去修改字节码文件来完成一些功能。它是一个java字节码操纵框架，它能被用来动态生成类或者增强既有类的功能。AS</p>
<h4 id="MySQL主键设计问题（2021-11-12-14-07-11-阅读-69-评论-0）"><a href="#MySQL主键设计问题（2021-11-12-14-07-11-阅读-69-评论-0）" class="headerlink" title="MySQL主键设计问题（2021-11-12 14:07:11 | 阅读 69 | 评论 0）"></a><a href="https://juejin.cn/post/7029560803036495908">MySQL主键设计问题</a>（2021-11-12 14:07:11 | 阅读 69 | 评论 0）</h4><p>这是我参与11月更文挑战的第10天，活动详情查看：2021最后一次更文挑战 mysql每个表必须有主键 如果没有显式指定主键，mysql会按照如下方式选择或者创建主键 如果表中有非空的唯一索引，采用该</p>
<h4 id="幂等性问题概述（2021-11-11-10-21-13-阅读-92-评论-0）"><a href="#幂等性问题概述（2021-11-11-10-21-13-阅读-92-评论-0）" class="headerlink" title="幂等性问题概述（2021-11-11 10:21:13 | 阅读 92 | 评论 0）"></a><a href="https://juejin.cn/post/7029131477354840094">幂等性问题概述</a>（2021-11-11 10:21:13 | 阅读 92 | 评论 0）</h4><p>这是我参与11月更文挑战的第9天，活动详情查看：2021最后一次更文挑战 问题场景 重试多次执行幂等 前端页面重复提交表单。 服务间调用有超时重试机制。请求已经执行成功了，但是没有收到返回结果，然后调</p>
<h4 id="缓存问题速记（2021-11-10-11-35-54-阅读-56-评论-0）"><a href="#缓存问题速记（2021-11-10-11-35-54-阅读-56-评论-0）" class="headerlink" title="缓存问题速记（2021-11-10 11:35:54 | 阅读 56 | 评论 0）"></a><a href="https://juejin.cn/post/7028779690836328455">缓存问题速记</a>（2021-11-10 11:35:54 | 阅读 56 | 评论 0）</h4><p>缓存雪崩 数据库每秒 1000的并发是⼀个正常的指标，一旦缓存宕机，过期时间一致导致缓存同时失效。请求打到数据库，数据库就崩了。重启数据库，⽴⻢⼜会被新的请求打死了。 解决 事前：redis⾼可⽤，主</p>
<h4 id="volatile原理（2021-11-09-11-24-55-阅读-72-评论-0）"><a href="#volatile原理（2021-11-09-11-24-55-阅读-72-评论-0）" class="headerlink" title="volatile原理（2021-11-09 11:24:55 | 阅读 72 | 评论 0）"></a><a href="https://juejin.cn/post/7028405742075904014">volatile原理</a>（2021-11-09 11:24:55 | 阅读 72 | 评论 0）</h4><p>这是我参与11月更文挑战的第7天，活动详情查看：2021最后一次更文挑战 volatile是Java虚拟机提供的最轻量级的同步机制 直观上的作用 并发可见性 防止指令重排序 实现原理 可见性保证 为什</p>
<h4 id="Spring循环依赖解析（2021-11-06-23-30-24-阅读-118-评论-0）"><a href="#Spring循环依赖解析（2021-11-06-23-30-24-阅读-118-评论-0）" class="headerlink" title="Spring循环依赖解析（2021-11-06 23:30:24 | 阅读 118 | 评论 0）"></a><a href="https://juejin.cn/post/7027479122062688286">Spring循环依赖解析</a>（2021-11-06 23:30:24 | 阅读 118 | 评论 0）</h4><p>这是我参与11月更文挑战的第6天，活动详情查看：2021最后一次更文挑战 原理 Spring主要解决的方案就是 bean的实例化和bean的属性填充分离 再结合一个三级缓存 实现的。 一级缓存：sin</p>
<h4 id="SpringBoot一些重要知识点速记（2021-11-05-23-49-50-阅读-214-评论-0）"><a href="#SpringBoot一些重要知识点速记（2021-11-05-23-49-50-阅读-214-评论-0）" class="headerlink" title="SpringBoot一些重要知识点速记（2021-11-05 23:49:50 | 阅读 214 | 评论 0）"></a><a href="https://juejin.cn/post/7027112941790953509">SpringBoot一些重要知识点速记</a>（2021-11-05 23:49:50 | 阅读 214 | 评论 0）</h4><p>这是我参与11月更文挑战的第5天，活动详情查看：2021最后一次更文挑战 SpringBoot整合tomcat原理（很简单，没那么复杂） SpringBoot项目在启动的时候，如果发现当前项目是一个w</p>
<h4 id="SpringMVC启动流程（2021-11-04-23-21-25-阅读-72-评论-0）"><a href="#SpringMVC启动流程（2021-11-04-23-21-25-阅读-72-评论-0）" class="headerlink" title="SpringMVC启动流程（2021-11-04 23:21:25 | 阅读 72 | 评论 0）"></a><a href="https://juejin.cn/post/7026734821644697637">SpringMVC启动流程</a>（2021-11-04 23:21:25 | 阅读 72 | 评论 0）</h4><p>这是我参与11月更文挑战的第4天，活动详情查看：2021最后一次更文挑战 分享下SpringMVC相关知识点速记 预备知识 首先需要了解下tomcat和spring这些是怎么整合在一起的 tomcat</p>
<h4 id="SpringMVC执行流程（2021-11-04-00-00-00-阅读-501-评论-0）"><a href="#SpringMVC执行流程（2021-11-04-00-00-00-阅读-501-评论-0）" class="headerlink" title="SpringMVC执行流程（2021-11-04 00:00:00 | 阅读 501 | 评论 0）"></a><a href="https://juejin.cn/post/7026373952259751972">SpringMVC执行流程</a>（2021-11-04 00:00:00 | 阅读 501 | 评论 0）</h4><p>这是我参与11月更文挑战的第3天，活动详情查看：2021最后一次更文挑战 SpringMVC的执行流程其实重点就是DispatcherSerlvet、handlermappings，handlerAd</p>
<h4 id="Spring源码速记-Bean生命周期（2021-11-02-23-24-34-阅读-290-评论-3）"><a href="#Spring源码速记-Bean生命周期（2021-11-02-23-24-34-阅读-290-评论-3）" class="headerlink" title="Spring源码速记 - Bean生命周期（2021-11-02 23:24:34 | 阅读 290 | 评论 3）"></a><a href="https://juejin.cn/post/7025993711309815816">Spring源码速记 - Bean生命周期</a>（2021-11-02 23:24:34 | 阅读 290 | 评论 3）</h4><p>这是我参与11月更文挑战的第2天，活动详情查看：2021最后一次更文挑战 Bean的生命周期其实就是Spring从创建到销毁一个Bean的过程。 BeanDefinition阶段 扫描解析Bean类为</p>
<h4 id="Spring源码速记-容器启动过程（2021-11-01-21-41-15-阅读-101-评论-0）"><a href="#Spring源码速记-容器启动过程（2021-11-01-21-41-15-阅读-101-评论-0）" class="headerlink" title="Spring源码速记 - 容器启动过程（2021-11-01 21:41:15 | 阅读 101 | 评论 0）"></a><a href="https://juejin.cn/post/7025595802894647303">Spring源码速记 - 容器启动过程</a>（2021-11-01 21:41:15 | 阅读 101 | 评论 0）</h4><p>这是我参与11月更文挑战的第1天，活动详情查看：2021最后一次更文挑战 这类面试八股文，即使看完了源码，不自己再去总结和记忆，时间长了相当于没看。即使Spring的很多知识点都懂了，但是面试真正需要</p>
<h4 id="MyBatis-Plus的BaseMapper实现原理（2021-08-31-11-01-02-阅读-7186-评论-1）"><a href="#MyBatis-Plus的BaseMapper实现原理（2021-08-31-11-01-02-阅读-7186-评论-1）" class="headerlink" title="MyBatis-Plus的BaseMapper实现原理（2021-08-31 11:01:02 | 阅读 7186 | 评论 1）"></a><a href="https://juejin.cn/post/7002423698565103653">MyBatis-Plus的BaseMapper实现原理</a>（2021-08-31 11:01:02 | 阅读 7186 | 评论 1）</h4><p>这是我参与8月更文挑战的第21天，活动详情查看：8月更文挑战 Mybatis-plus为我们提供了一些通用mapper方法，比如insert，update，selectById等等</p>
<h4 id="LSM-Tree简介（2021-08-30-10-09-27-阅读-920-评论-0）"><a href="#LSM-Tree简介（2021-08-30-10-09-27-阅读-920-评论-0）" class="headerlink" title="LSM-Tree简介（2021-08-30 10:09:27 | 阅读 920 | 评论 0）"></a><a href="https://juejin.cn/post/7002039421885218823">LSM-Tree简介</a>（2021-08-30 10:09:27 | 阅读 920 | 评论 0）</h4><p>这是我参与8月更文挑战的第20天，活动详情查看：8月更文挑战 前言 LSM-Tree全称是Log Structured Merge Tree（日志结构合并树），最早听过这个存储引擎概念还是在《Bigt</p>
<h4 id="git-rebase为啥不推荐使用（2021-08-29-13-16-02-阅读-912-评论-0）"><a href="#git-rebase为啥不推荐使用（2021-08-29-13-16-02-阅读-912-评论-0）" class="headerlink" title="git rebase为啥不推荐使用（2021-08-29 13:16:02 | 阅读 912 | 评论 0）"></a><a href="https://juejin.cn/post/7001715977033383973">git rebase为啥不推荐使用</a>（2021-08-29 13:16:02 | 阅读 912 | 评论 0）</h4><p>这是我参与8月更文挑战的第19天，活动详情查看：8月更文挑战 在刚开始工作的时候，部门一个配管的老师傅强制命令过我们不要使用git rebase，当时不知道为啥。后面慢慢的就习惯了git merge去</p>
<h4 id="闭包-—-从抽象到形象过程（2021-08-28-22-57-12-阅读-271-评论-0）"><a href="#闭包-—-从抽象到形象过程（2021-08-28-22-57-12-阅读-271-评论-0）" class="headerlink" title="闭包 — 从抽象到形象过程（2021-08-28 22:57:12 | 阅读 271 | 评论 0）"></a><a href="https://juejin.cn/post/7001494136293425189">闭包 — 从抽象到形象过程</a>（2021-08-28 22:57:12 | 阅读 271 | 评论 0）</h4><p>这是我参与8月更文挑战的第18天，活动详情查看：8月更文挑战 什么是闭包 其实意思也很好懂了，我们知道程序都有域的概念，从顶级的命名空间到java&#x2F;C++等{ }的域界定符，程序就是代码块或嵌套或并列</p>
<h4 id="缓存一致性协议MESI详解（2021-08-27-22-53-14-阅读-2250-评论-0）"><a href="#缓存一致性协议MESI详解（2021-08-27-22-53-14-阅读-2250-评论-0）" class="headerlink" title="缓存一致性协议MESI详解（2021-08-27 22:53:14 | 阅读 2250 | 评论 0）"></a><a href="https://juejin.cn/post/7001122798122827806">缓存一致性协议MESI详解</a>（2021-08-27 22:53:14 | 阅读 2250 | 评论 0）</h4><p>这是我参与8月更文挑战的第17天，活动详情查看：8月更文挑战 CPU的缓存结构 我们知道CPU的运算速度是很快的，因为从磁盘获取的数据的速度严重影响着效率，所以此有了DRAM（内存），但是即便是这样，</p>
<h4 id="Spring之-Import（2021-08-26-00-09-09-阅读-483-评论-0）"><a href="#Spring之-Import（2021-08-26-00-09-09-阅读-483-评论-0）" class="headerlink" title="Spring之@Import（2021-08-26 00:09:09 | 阅读 483 | 评论 0）"></a><a href="https://juejin.cn/post/7000398861441171487">Spring之@Import</a>（2021-08-26 00:09:09 | 阅读 483 | 评论 0）</h4><p>这是我参与8月更文挑战的第16天，活动详情查看：8月更文挑战 @Import是Spring注入Bean的方式之一。 为什么有这个 先看其他的方式： @Component及其对应的衍生注解就不用说了，这</p>
<h4 id="CPU的工作原理-运行流程（2021-08-25-10-13-16-阅读-712-评论-0）"><a href="#CPU的工作原理-运行流程（2021-08-25-10-13-16-阅读-712-评论-0）" class="headerlink" title="CPU的工作原理 - 运行流程（2021-08-25 10:13:16 | 阅读 712 | 评论 0）"></a><a href="https://juejin.cn/post/7000185021625548837">CPU的工作原理 - 运行流程</a>（2021-08-25 10:13:16 | 阅读 712 | 评论 0）</h4><p>这是我参与8月更文挑战的第15天，活动详情查看：8月更文挑战 我们大多使用的是Intel或者AMD的CPU，但是本文只以《But How Do It Know》书中给出的一个简略版的CPU（称为Sco</p>
<h4 id="CPU的工作原理-组成部分（2021-08-24-00-31-04-阅读-1317-评论-0）"><a href="#CPU的工作原理-组成部分（2021-08-24-00-31-04-阅读-1317-评论-0）" class="headerlink" title="CPU的工作原理 - 组成部分（2021-08-24 00:31:04 | 阅读 1317 | 评论 0）"></a><a href="https://juejin.cn/post/6999663181291323423">CPU的工作原理 - 组成部分</a>（2021-08-24 00:31:04 | 阅读 1317 | 评论 0）</h4><p>这是我参与8月更文挑战的第14天，活动详情查看：8月更文挑战 当代的CPU(central processing unit)，是一块超大规模的集成电路。我们知道计算机的世界是有0和1组成的，那是因为构</p>
<h4 id="CPU的工作原理-芯片（2021-08-23-00-01-32-阅读-198-评论-0）"><a href="#CPU的工作原理-芯片（2021-08-23-00-01-32-阅读-198-评论-0）" class="headerlink" title="CPU的工作原理 - 芯片（2021-08-23 00:01:32 | 阅读 198 | 评论 0）"></a><a href="https://juejin.cn/post/6999284701580001316">CPU的工作原理 - 芯片</a>（2021-08-23 00:01:32 | 阅读 198 | 评论 0）</h4><p>这是我参与8月更文挑战的第13天，活动详情查看：8月更文挑战 CPU的工作原理 简介 CPU(central processing unit)，又叫中央处理器，可以说是目前人类历史上科技含量最高的产物</p>
<h4 id="Spring注入Bean的几种方式-（2021-08-18-22-54-54-阅读-1377-评论-0）"><a href="#Spring注入Bean的几种方式-（2021-08-18-22-54-54-阅读-1377-评论-0）" class="headerlink" title="Spring注入Bean的几种方式 （2021-08-18 22:54:54 | 阅读 1377 | 评论 0）"></a><a href="https://juejin.cn/post/6997783245521682463">Spring注入Bean的几种方式 </a>（2021-08-18 22:54:54 | 阅读 1377 | 评论 0）</h4><p>这是我参与8月更文挑战的第12天，活动详情查看：8月更文挑战 Spring注入Bean的几种方式 简单罗列下Spring注入Bean的几种方式。 XML注入 早期的Spring，特别是springbo</p>
<h4 id="MyBatis接口是如何执行SQL的？-总结篇（2021-08-14-12-55-10-阅读-585-评论-0）"><a href="#MyBatis接口是如何执行SQL的？-总结篇（2021-08-14-12-55-10-阅读-585-评论-0）" class="headerlink" title="MyBatis接口是如何执行SQL的？- 总结篇（2021-08-14 12:55:10 | 阅读 585 | 评论 0）"></a><a href="https://juejin.cn/post/6996143167615533093">MyBatis接口是如何执行SQL的？- 总结篇</a>（2021-08-14 12:55:10 | 阅读 585 | 评论 0）</h4><p>这是我参与8月更文挑战的第11天，活动详情查看：8月更文挑战 本文对MyBatis接口是如何执行SQL做一个总结，其实我们是带着这几个问题来追踪答案的： mapper接口是如何被spring发现的？ </p>
<h4 id="MyBatis接口是如何执行SQL的？-mapper注入篇（2021-08-13-10-33-50-阅读-887-评论-0）"><a href="#MyBatis接口是如何执行SQL的？-mapper注入篇（2021-08-13-10-33-50-阅读-887-评论-0）" class="headerlink" title="MyBatis接口是如何执行SQL的？- mapper注入篇（2021-08-13 10:33:50 | 阅读 887 | 评论 0）"></a><a href="https://juejin.cn/post/6995737044148289549">MyBatis接口是如何执行SQL的？- mapper注入篇</a>（2021-08-13 10:33:50 | 阅读 887 | 评论 0）</h4><p>这是我参与8月更文挑战的第10天，活动详情查看：8月更文挑战 上文我们只是知道了springboot的自动装配是怎么帮我们来创建SqlSessionFactory的，在上面的步骤后，容器里面此时就存在</p>
<h4 id="MyBatis接口是如何执行SQL的？-自动配置篇（2021-08-12-15-54-11-阅读-337-评论-0）"><a href="#MyBatis接口是如何执行SQL的？-自动配置篇（2021-08-12-15-54-11-阅读-337-评论-0）" class="headerlink" title="MyBatis接口是如何执行SQL的？- 自动配置篇（2021-08-12 15:54:11 | 阅读 337 | 评论 0）"></a><a href="https://juejin.cn/post/6995448330310385694">MyBatis接口是如何执行SQL的？- 自动配置篇</a>（2021-08-12 15:54:11 | 阅读 337 | 评论 0）</h4><p>这是我参与8月更文挑战的第9天，活动详情查看：8月更文挑战 前面文档（Mybatis源码解析-快速一览）我简单快速的描述了Mybatis的一个整体的源码流程，本文主要聊一下Mybatis一个热门的面试</p>
<h4 id="Repo简介（2021-08-09-00-00-10-阅读-1208-评论-0）"><a href="#Repo简介（2021-08-09-00-00-10-阅读-1208-评论-0）" class="headerlink" title="Repo简介（2021-08-09 00:00:10 | 阅读 1208 | 评论 0）"></a><a href="https://juejin.cn/post/6994089189570527263">Repo简介</a>（2021-08-09 00:00:10 | 阅读 1208 | 评论 0）</h4><p>这是我参与8月更文挑战的第8天，活动详情查看：8月更文挑战 什么是Repo？ Repo是谷歌提供的一套Python脚本，它封装一系列git命令，用来管理多个git库（最典型的的就是Android）作为</p>
<h4 id="Java序列化（2021-08-07-23-22-00-阅读-291-评论-0）"><a href="#Java序列化（2021-08-07-23-22-00-阅读-291-评论-0）" class="headerlink" title="Java序列化（2021-08-07 23:22:00 | 阅读 291 | 评论 0）"></a><a href="https://juejin.cn/post/6993708104781135908">Java序列化</a>（2021-08-07 23:22:00 | 阅读 291 | 评论 0）</h4><p>这是我参与8月更文挑战的第7天，活动详情查看：8月更文挑战 当我们想要将一个Java对象存储在一个临时媒介或者网络传输出去等等这些场景的时候，就需要需要使用到序列化和反序列化技术。Java序列化就是指</p>
<h4 id="类加载机制（2021-08-06-21-00-41-阅读-98-评论-0）"><a href="#类加载机制（2021-08-06-21-00-41-阅读-98-评论-0）" class="headerlink" title="类加载机制（2021-08-06 21:00:41 | 阅读 98 | 评论 0）"></a><a href="https://juejin.cn/post/6993301147553366029">类加载机制</a>（2021-08-06 21:00:41 | 阅读 98 | 评论 0）</h4><p>这是我参与8月更文挑战的第6天，活动详情查看：8月更文挑战 类加载的流程 加载：将.class文件读取到jvm内存中； 验证：确保加载进来的字节流符合JVM规范； 准备：为静态变量在方法区分配内存，并</p>
<h4 id="布隆过滤器简介（2021-08-05-21-10-19-阅读-76-评论-0）"><a href="#布隆过滤器简介（2021-08-05-21-10-19-阅读-76-评论-0）" class="headerlink" title="布隆过滤器简介（2021-08-05 21:10:19 | 阅读 76 | 评论 0）"></a><a href="https://juejin.cn/post/6992932112483811365">布隆过滤器简介</a>（2021-08-05 21:10:19 | 阅读 76 | 评论 0）</h4><p>这是我参与8月更文挑战的第5天，活动详情查看：8月更文挑战 本文只对布隆过滤器做简单了解。 背景 我们想要判断一个集合中是否存在某个元素，该怎么做？ 我们大概想出的解决方案，就是定义map或者类似的h</p>
<h4 id="Redis的基本数据结构及原理（2021-08-02-20-31-46-阅读-637-评论-0）"><a href="#Redis的基本数据结构及原理（2021-08-02-20-31-46-阅读-637-评论-0）" class="headerlink" title="Redis的基本数据结构及原理（2021-08-02 20:31:46 | 阅读 637 | 评论 0）"></a><a href="https://juejin.cn/post/6991808264530821151">Redis的基本数据结构及原理</a>（2021-08-02 20:31:46 | 阅读 637 | 评论 0）</h4><p>简要记录下redis基本数据结构及内部实现的原理。这里面其实每种结构都可以单独写一篇，后期有时间做拆分详细说明。 String 等同于Java中的ArrayList。内部是一个字符数组（动态数组）。 </p>
<h4 id="一致性hash原理（2021-08-01-17-18-47-阅读-528-评论-2）"><a href="#一致性hash原理（2021-08-01-17-18-47-阅读-528-评论-2）" class="headerlink" title="一致性hash原理（2021-08-01 17:18:47 | 阅读 528 | 评论 2）"></a><a href="https://juejin.cn/post/6991388409298157576">一致性hash原理</a>（2021-08-01 17:18:47 | 阅读 528 | 评论 2）</h4><p>一致性哈希算法在1997年由麻省理工学院提出，是一种特殊的哈希算法，目的是解决分布式缓存的问题。该算法是1997年在论文*《Consistent hashing and random trees》</p>
<h4 id="Maven-项目部署实践的一些思考（2021-07-03-21-18-30-阅读-1145-评论-0）"><a href="#Maven-项目部署实践的一些思考（2021-07-03-21-18-30-阅读-1145-评论-0）" class="headerlink" title="Maven 项目部署实践的一些思考（2021-07-03 21:18:30 | 阅读 1145 | 评论 0）"></a><a href="https://juejin.cn/post/6980688120563892237">Maven 项目部署实践的一些思考</a>（2021-07-03 21:18:30 | 阅读 1145 | 评论 0）</h4><p>maven项目在日常开发和上线部署整个流程环节做一个整体的概述，以及阐述当前我自己开发和部署环节中摸索出来的一些方法论</p>
<h4 id="调整数组顺序使奇数位于偶数前面｜刷题打卡（2021-04-18-22-07-57-阅读-115-评论-0）"><a href="#调整数组顺序使奇数位于偶数前面｜刷题打卡（2021-04-18-22-07-57-阅读-115-评论-0）" class="headerlink" title="调整数组顺序使奇数位于偶数前面｜刷题打卡（2021-04-18 22:07:57 | 阅读 115 | 评论 0）"></a><a href="https://juejin.cn/post/6952499028231716894">调整数组顺序使奇数位于偶数前面｜刷题打卡</a>（2021-04-18 22:07:57 | 阅读 115 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。示例：输入输出注</p>
<h4 id="矩阵中的路径｜刷题打卡（2021-04-18-22-03-39-阅读-100-评论-0）"><a href="#矩阵中的路径｜刷题打卡（2021-04-18-22-03-39-阅读-100-评论-0）" class="headerlink" title="矩阵中的路径｜刷题打卡（2021-04-18 22:03:39 | 阅读 100 | 评论 0）"></a><a href="https://juejin.cn/post/6952497764757012487">矩阵中的路径｜刷题打卡</a>（2021-04-18 22:03:39 | 阅读 100 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、</p>
<h4 id="剪绳子｜刷题打卡（2021-04-18-21-42-57-阅读-302-评论-0）"><a href="#剪绳子｜刷题打卡（2021-04-18-21-42-57-阅读-302-评论-0）" class="headerlink" title="剪绳子｜刷题打卡（2021-04-18 21:42:57 | 阅读 302 | 评论 0）"></a><a href="https://juejin.cn/post/6952492544861143054">剪绳子｜刷题打卡</a>（2021-04-18 21:42:57 | 阅读 302 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1</p>
<h4 id="栈的压入弹出序列｜刷题打卡（2021-04-18-21-32-39-阅读-208-评论-0）"><a href="#栈的压入弹出序列｜刷题打卡（2021-04-18-21-32-39-阅读-208-评论-0）" class="headerlink" title="栈的压入弹出序列｜刷题打卡（2021-04-18 21:32:39 | 阅读 208 | 评论 0）"></a><a href="https://juejin.cn/post/6952489301573632014">栈的压入弹出序列｜刷题打卡</a>（2021-04-18 21:32:39 | 阅读 208 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,</p>
<h4 id="两个链表的第一个公共节点｜刷题打卡（2021-04-18-21-24-41-阅读-166-评论-0）"><a href="#两个链表的第一个公共节点｜刷题打卡（2021-04-18-21-24-41-阅读-166-评论-0）" class="headerlink" title="两个链表的第一个公共节点｜刷题打卡（2021-04-18 21:24:41 | 阅读 166 | 评论 0）"></a><a href="https://juejin.cn/post/6952487074683420680">两个链表的第一个公共节点｜刷题打卡</a>（2021-04-18 21:24:41 | 阅读 166 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述输入两个链表，找出它们的第一个公共节点。如下面的两个链表：在节点 c1 开始相交。示例 1：输入输出输入解释：相交节点的值为 8 （</p>
<h4 id="数组中出现次数超过一半的数字｜刷题打卡（2021-04-18-20-54-09-阅读-79-评论-0）"><a href="#数组中出现次数超过一半的数字｜刷题打卡（2021-04-18-20-54-09-阅读-79-评论-0）" class="headerlink" title="数组中出现次数超过一半的数字｜刷题打卡（2021-04-18 20:54:09 | 阅读 79 | 评论 0）"></a><a href="https://juejin.cn/post/6952480119684333598">数组中出现次数超过一半的数字｜刷题打卡</a>（2021-04-18 20:54:09 | 阅读 79 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。示例:输入输出</p>
<h4 id="包含min函数的栈｜刷题打卡（2021-04-18-20-47-08-阅读-241-评论-1）"><a href="#包含min函数的栈｜刷题打卡（2021-04-18-20-47-08-阅读-241-评论-1）" class="headerlink" title="包含min函数的栈｜刷题打卡（2021-04-18 20:47:08 | 阅读 241 | 评论 1）"></a><a href="https://juejin.cn/post/6952475949795393550">包含min函数的栈｜刷题打卡</a>（2021-04-18 20:47:08 | 阅读 241 | 评论 1）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度</p>
<h4 id="对称的二叉树｜刷题打卡（2021-04-18-20-33-45-阅读-48-评论-0）"><a href="#对称的二叉树｜刷题打卡（2021-04-18-20-33-45-阅读-48-评论-0）" class="headerlink" title="对称的二叉树｜刷题打卡（2021-04-18 20:33:45 | 阅读 48 | 评论 0）"></a><a href="https://juejin.cn/post/6952474477305266190">对称的二叉树｜刷题打卡</a>（2021-04-18 20:33:45 | 阅读 48 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。示例:例如，二叉树 [1,2,2,3,</p>
<h4 id="二进制中1的个数｜刷题打卡（2021-04-18-20-24-13-阅读-216-评论-0）"><a href="#二进制中1的个数｜刷题打卡（2021-04-18-20-24-13-阅读-216-评论-0）" class="headerlink" title="二进制中1的个数｜刷题打卡（2021-04-18 20:24:13 | 阅读 216 | 评论 0）"></a><a href="https://juejin.cn/post/6952471118078984228">二进制中1的个数｜刷题打卡</a>（2021-04-18 20:24:13 | 阅读 216 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位</p>
<h4 id="青蛙跳台阶问题｜刷题打卡（2021-04-18-20-15-22-阅读-192-评论-0）"><a href="#青蛙跳台阶问题｜刷题打卡（2021-04-18-20-15-22-阅读-192-评论-0）" class="headerlink" title="青蛙跳台阶问题｜刷题打卡（2021-04-18 20:15:22 | 阅读 192 | 评论 0）"></a><a href="https://juejin.cn/post/6952469261658882061">青蛙跳台阶问题｜刷题打卡</a>（2021-04-18 20:15:22 | 阅读 192 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000</p>
<h4 id="两个栈实现队列｜刷题打卡（2021-04-18-20-07-59-阅读-49-评论-0）"><a href="#两个栈实现队列｜刷题打卡（2021-04-18-20-07-59-阅读-49-评论-0）" class="headerlink" title="两个栈实现队列｜刷题打卡（2021-04-18 20:07:59 | 阅读 49 | 评论 0）"></a><a href="https://juejin.cn/post/6952467028145864735">两个栈实现队列｜刷题打卡</a>（2021-04-18 20:07:59 | 阅读 49 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整</p>
<h4 id="数组中重复的数字｜刷题打卡（2021-04-15-11-25-32-阅读-279-评论-0）"><a href="#数组中重复的数字｜刷题打卡（2021-04-15-11-25-32-阅读-279-评论-0）" class="headerlink" title="数组中重复的数字｜刷题打卡（2021-04-15 11:25:32 | 阅读 279 | 评论 0）"></a><a href="https://juejin.cn/post/6951220205980745736">数组中重复的数字｜刷题打卡</a>（2021-04-15 11:25:32 | 阅读 279 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知</p>
<h4 id="柠檬水找零｜刷题打卡（2021-04-15-11-09-17-阅读-131-评论-0）"><a href="#柠檬水找零｜刷题打卡（2021-04-15-11-09-17-阅读-131-评论-0）" class="headerlink" title="柠檬水找零｜刷题打卡（2021-04-15 11:09:17 | 阅读 131 | 评论 0）"></a><a href="https://juejin.cn/post/6951216190177935396">柠檬水找零｜刷题打卡</a>（2021-04-15 11:09:17 | 阅读 131 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯</p>
<h4 id="镜像二叉树｜刷题打卡（2021-04-15-10-56-00-阅读-212-评论-0）"><a href="#镜像二叉树｜刷题打卡（2021-04-15-10-56-00-阅读-212-评论-0）" class="headerlink" title="镜像二叉树｜刷题打卡（2021-04-15 10:56:00 | 阅读 212 | 评论 0）"></a><a href="https://juejin.cn/post/6951212215324114974">镜像二叉树｜刷题打卡</a>（2021-04-15 10:56:00 | 阅读 212 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述请完成一个函数，输入一个二叉树，该函数输出它的镜像。示例:现有矩阵 matrix 如下：镜像输出：程序输出实例：限制：二、思路分析我</p>
<h4 id="二维数组中的找数｜刷题打卡（2021-04-10-19-10-04-阅读-75-评论-0）"><a href="#二维数组中的找数｜刷题打卡（2021-04-10-19-10-04-阅读-75-评论-0）" class="headerlink" title="二维数组中的找数｜刷题打卡（2021-04-10 19:10:04 | 阅读 75 | 评论 0）"></a><a href="https://juejin.cn/post/6949482427911766024">二维数组中的找数｜刷题打卡</a>（2021-04-10 19:10:04 | 阅读 75 | 评论 0）</h4><p>掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入</p>
<h4 id="Mybatis源码解析-快速一览（2021-03-31-20-57-45-阅读-630-评论-1）"><a href="#Mybatis源码解析-快速一览（2021-03-31-20-57-45-阅读-630-评论-1）" class="headerlink" title="Mybatis源码解析-快速一览（2021-03-31 20:57:45 | 阅读 630 | 评论 1）"></a><a href="https://juejin.cn/post/6945800856277106718">Mybatis源码解析-快速一览</a>（2021-03-31 20:57:45 | 阅读 630 | 评论 1）</h4><p>XMLConfigBuilder.parseConfiguration()方法先去解析mybatis-config.xml文件，将所有的配置封装到Configuration类中。 parseConfiguration方法会按照一定顺序来解析mybatis-config.xml中…</p>
<h4 id="Mybatis插件的一个小坑（2021-03-31-20-55-27-阅读-688-评论-2）"><a href="#Mybatis插件的一个小坑（2021-03-31-20-55-27-阅读-688-评论-2）" class="headerlink" title="Mybatis插件的一个小坑（2021-03-31 20:55:27 | 阅读 688 | 评论 2）"></a><a href="https://juejin.cn/post/6945800069668945928">Mybatis插件的一个小坑</a>（2021-03-31 20:55:27 | 阅读 688 | 评论 2）</h4><p>当时写完了，写了个测试发现没有问题就一直没管了，今天debug过程中发现，执行某些Mapper接口方法的时候，都不走这个插件，致使所有的sql其实都会请求到默认主库上去。 于是我把断点打在Executor的query(MappedStatement ms, Object par…</p>
<h4 id="ThreadLocal-使用及原理详解（2021-03-20-21-32-35-阅读-697-评论-1）"><a href="#ThreadLocal-使用及原理详解（2021-03-20-21-32-35-阅读-697-评论-1）" class="headerlink" title="ThreadLocal 使用及原理详解（2021-03-20 21:32:35 | 阅读 697 | 评论 1）"></a><a href="https://juejin.cn/post/6941727688704917518">ThreadLocal 使用及原理详解</a>（2021-03-20 21:32:35 | 阅读 697 | 评论 1）</h4><p>这算是日常处理并发问题中，比较常见和易用一个技术点了。无论框架中还是平时业务开发中，有时候就特别适合使用ThreadLocal来解决一些问题。 ThreadLocal（又被称为线程本地变量）。字面意思，每个线程拥有本地变量的副本，各个线程之间的变量互不干扰。相对很多线程同步代码…</p>
<h4 id="SpringBoot实战-跨域问题原理及解决（2021-03-05-10-10-02-阅读-2972-评论-0）"><a href="#SpringBoot实战-跨域问题原理及解决（2021-03-05-10-10-02-阅读-2972-评论-0）" class="headerlink" title="SpringBoot实战-跨域问题原理及解决（2021-03-05 10:10:02 | 阅读 2972 | 评论 0）"></a><a href="https://juejin.cn/post/6935985994386636831">SpringBoot实战-跨域问题原理及解决</a>（2021-03-05 10:10:02 | 阅读 2972 | 评论 0）</h4><p>浏览器为了页面安全，设置了同源策略：即本域脚本只能读写本域内的资源，而无法访问其它域的资源。所谓同源就是“协议+域名+端口”三者相同，当在一个站点内访问非该同源的资源，浏览器就会报跨域错误。浏览器的两种同源策略会造成跨域问题： DOM同源策略。禁止对不同源的页面的DOM进行操作…</p>
<h4 id="SpringBoot实战-多数据源方案一些思考（2021-03-03-10-27-49-阅读-1398-评论-1）"><a href="#SpringBoot实战-多数据源方案一些思考（2021-03-03-10-27-49-阅读-1398-评论-1）" class="headerlink" title="SpringBoot实战-多数据源方案一些思考（2021-03-03 10:27:49 | 阅读 1398 | 评论 1）"></a><a href="https://juejin.cn/post/6935248911388901390">SpringBoot实战-多数据源方案一些思考</a>（2021-03-03 10:27:49 | 阅读 1398 | 评论 1）</h4><p>目前微服务大行其道，大部分的架构都已经转为单服务单库来最大程度的解耦数据源的业务关联性。但是依然存在少数场景会遇到需要使用多数据源的场景。再则，撇开微服务来说，单体的SpringBoot服务在我们开发中，多数据源的情况就更加普遍了。本文主要聊聊多数据源的一些方案即对应的实现。 …</p>
<h4 id="阿里云第一届PolarDB数据库性能大赛Java排名第一分享-【转载】（2021-02-23-16-01-23-阅读-121-评论-0）"><a href="#阿里云第一届PolarDB数据库性能大赛Java排名第一分享-【转载】（2021-02-23-16-01-23-阅读-121-评论-0）" class="headerlink" title="阿里云第一届PolarDB数据库性能大赛Java排名第一分享 【转载】（2021-02-23 16:01:23 | 阅读 121 | 评论 0）"></a><a href="https://juejin.cn/post/6932365780294533127">阿里云第一届PolarDB数据库性能大赛Java排名第一分享 【转载】</a>（2021-02-23 16:01:23 | 阅读 121 | 评论 0）</h4><p>参加天池大赛-阿里云第一届PolarDB数据库性能大赛，比赛以NVME Optane SSD为背景，在此之上开发单机存储引擎比拼性能，支持C++和Java语言。我的完赛成绩是Java语言排名第一，总排名20（共1653人参赛，队伍名称：neoremind），与C++第一差距在2…</p>
<h4 id="dynamic-datasource-spring-boot-starter-源码解析（2021-02-18-20-36-59-阅读-6287-评论-9）"><a href="#dynamic-datasource-spring-boot-starter-源码解析（2021-02-18-20-36-59-阅读-6287-评论-9）" class="headerlink" title=" dynamic-datasource-spring-boot-starter 源码解析（2021-02-18 20:36:59 | 阅读 6287 | 评论 9）"></a><a href="https://juejin.cn/post/6930579615089950733"> dynamic-datasource-spring-boot-starter 源码解析</a>（2021-02-18 20:36:59 | 阅读 6287 | 评论 9）</h4><p>新公司很多地方使用了多数据源，之前老公司一直都是通过配置多个DataSource来解决的，在公司发现都喜欢用这个框架，就简单看看源码。源码地址 这是MP（Mybatis-plus）的组织苞米豆出品的一个多数据源方案，用的人还比较多。 首先，这是一个SpringBoot启动器，所…</p>
<h4 id="Spring-源码解析-环境搭建（2021-02-18-13-56-32-阅读-596-评论-2）"><a href="#Spring-源码解析-环境搭建（2021-02-18-13-56-32-阅读-596-评论-2）" class="headerlink" title="Spring 源码解析 - 环境搭建（2021-02-18 13:56:32 | 阅读 596 | 评论 2）"></a><a href="https://juejin.cn/post/6930477653607186440">Spring 源码解析 - 环境搭建</a>（2021-02-18 13:56:32 | 阅读 596 | 评论 2）</h4><p>学习源码个人建议还是当一份源码下来，自己编译运行一下，也方便做笔记等。虽然过程中会有一点磕绊，但整体来说，Spring的源码环境搭建还是比较容易的。 master等其他版本可能为spring内部开发人员使用的，会包含一些他们内部仓库才有的东西，所以最好切到某个relase的ta…</p>
<h4 id="Java-SPI-机制（2020-11-04-22-30-13-阅读-2149-评论-0）"><a href="#Java-SPI-机制（2020-11-04-22-30-13-阅读-2149-评论-0）" class="headerlink" title="Java SPI 机制（2020-11-04 22:30:13 | 阅读 2149 | 评论 0）"></a><a href="https://juejin.cn/post/6891275176504197134">Java SPI 机制</a>（2020-11-04 22:30:13 | 阅读 2149 | 评论 0）</h4><p>SPI，全称Service Provider Interface，是Java内置的服务发现机制（这个服务发现不是微服务里面注册中心那个服务发现）。 简单的来讲，Java的SPI机制就是指：针对一个接口，我们需要加载外部对该接口的实现，只要约定好将该实现配置在classPath路…</p>
<h4 id="【设计模式】访问者模式（2020-10-05-01-37-28-阅读-674-评论-0）"><a href="#【设计模式】访问者模式（2020-10-05-01-37-28-阅读-674-评论-0）" class="headerlink" title="【设计模式】访问者模式（2020-10-05 01:37:28 | 阅读 674 | 评论 0）"></a><a href="https://juejin.cn/post/6879817670368165902">【设计模式】访问者模式</a>（2020-10-05 01:37:28 | 阅读 674 | 评论 0）</h4><p>本文主要介绍访问者模式的概念及用法。 在系统，有时候一系列对象需要被以不同的方式访问。比如医院开的药方，在医院财务那这个药房只是用来计算价格，在抓药那里这个药方是用来抓药的。类比到实际项目使用中：一个集合里面可能会有几类元素，不同类型的元素可以有不同的访问者访问他，并且有不同的…</p>
<h4 id="【设计模式】模板方法模式（2020-09-12-00-43-59-阅读-519-评论-0）"><a href="#【设计模式】模板方法模式（2020-09-12-00-43-59-阅读-519-评论-0）" class="headerlink" title="【设计模式】模板方法模式（2020-09-12 00:43:59 | 阅读 519 | 评论 0）"></a><a href="https://juejin.cn/post/6871270815095062536">【设计模式】模板方法模式</a>（2020-09-12 00:43:59 | 阅读 519 | 评论 0）</h4><p>本文主要介绍模板方法模式的概念和用法。 生活中，我们自己装主机，我们确定好机架后，里面的具体的CPU，内存条，电源，主板等等配件，就可以使用不同的方案去配置这个电脑主机了。这里面其实就是和模板方法模式相同的思想：机架也是可以有好多种的，那么每一种机架就相当于是一个模板。每一个机…</p>
<h4 id="【设计模式】策略模式（2020-09-10-11-29-43-阅读-176-评论-0）"><a href="#【设计模式】策略模式（2020-09-10-11-29-43-阅读-176-评论-0）" class="headerlink" title="【设计模式】策略模式（2020-09-10 11:29:43 | 阅读 176 | 评论 0）"></a><a href="https://juejin.cn/post/6870695863489036302">【设计模式】策略模式</a>（2020-09-10 11:29:43 | 阅读 176 | 评论 0）</h4><p>本文主要介绍策略模式的概念和用法。 当实现某一个功能有多条途径，每种途径都对应一种逻辑或者算法，如何灵活的来实现途径的选择，就可以使用策略模式。 比如我们使用地图导航软件去某地的时候，有公交路线，自行车路线，地铁，步行等路线。每一个路线都对应着一个执行策略，这些策略都有用，在不…</p>
<h4 id="【设计模式】状态模式（2020-09-09-11-48-32-阅读-102-评论-0）"><a href="#【设计模式】状态模式（2020-09-09-11-48-32-阅读-102-评论-0）" class="headerlink" title="【设计模式】状态模式（2020-09-09 11:48:32 | 阅读 102 | 评论 0）"></a><a href="https://juejin.cn/post/6870329738020749326">【设计模式】状态模式</a>（2020-09-09 11:48:32 | 阅读 102 | 评论 0）</h4><p>本文主要介绍状态模式的概念以及用法。 生活中很多东西都会有不同的状态，并且在不同的状态下会有着不同的行为。比如，水可以分为固态，液态，汽态，在每一种态下面他的表现形式也不同。一个个人银行的账户，可能依据存钱或者欠钱的额度在银行中标记为不同状态，VIP可以每日转额度10w，欠款用…</p>
<h4 id="【设计模式】观察者模式（2020-09-08-11-25-42-阅读-486-评论-0）"><a href="#【设计模式】观察者模式（2020-09-08-11-25-42-阅读-486-评论-0）" class="headerlink" title="【设计模式】观察者模式（2020-09-08 11:25:42 | 阅读 486 | 评论 0）"></a><a href="https://juejin.cn/post/6869952662550937607">【设计模式】观察者模式</a>（2020-09-08 11:25:42 | 阅读 486 | 评论 0）</h4><p>本文主要介绍观察者模式的概念和用法，以及jdk提供的观察者模式支持。 我们在项目开发中会存在当一个对象发生变化的时候，其他的一些对象也需要跟着变更自己的状态或者去做一些操作。比如一个微信公众号，当号主发布了一篇文章之后，所有关注了这个公众号的用户都会受到该文章的推送。这种一个对…</p>
<h4 id="【设计模式】备忘录模式（2020-09-07-11-16-38-阅读-468-评论-0）"><a href="#【设计模式】备忘录模式（2020-09-07-11-16-38-阅读-468-评论-0）" class="headerlink" title="【设计模式】备忘录模式（2020-09-07 11:16:38 | 阅读 468 | 评论 0）"></a><a href="https://juejin.cn/post/6869578987551588359">【设计模式】备忘录模式</a>（2020-09-07 11:16:38 | 阅读 468 | 评论 0）</h4><p>本文主要介绍备忘录模式概念和用法。 备忘录模式是为了解决系统中状态回退，撤销问题的。比如系统功能中的回到上一步，下棋悔棋等。我们可能因为当前的状态存在了问题，需要回滚到上一个状态去。 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象…</p>
<h4 id="【设计模式】中介者模式（2020-08-28-11-31-00-阅读-86-评论-0）"><a href="#【设计模式】中介者模式（2020-08-28-11-31-00-阅读-86-评论-0）" class="headerlink" title="【设计模式】中介者模式（2020-08-28 11:31:00 | 阅读 86 | 评论 0）"></a><a href="https://juejin.cn/post/6865872205201276942">【设计模式】中介者模式</a>（2020-08-28 11:31:00 | 阅读 86 | 评论 0）</h4><p>本文主要介绍中介者模式的概念和用法。 实际开发中，我们存在很多广播性质的需求。比如说当我们发送一个消息，希望很多人同时收到，所以有了QQ群这个功能。有了QQ群，我们就不需要通过自己一个个去发送消息，也就是说这个QQ群帮我和其他的用户进行了解耦。类似于QQ群这样一个引入中间者思想…</p>
<h4 id="【设计模式】迭代器模式（2020-08-27-14-56-44-阅读-92-评论-0）"><a href="#【设计模式】迭代器模式（2020-08-27-14-56-44-阅读-92-评论-0）" class="headerlink" title="【设计模式】迭代器模式（2020-08-27 14:56:44 | 阅读 92 | 评论 0）"></a><a href="https://juejin.cn/post/6865554195567607816">【设计模式】迭代器模式</a>（2020-08-27 14:56:44 | 阅读 92 | 评论 0）</h4><p>本文主要介绍迭代器模式原理和实现。 对于一个list型数据，一般都会承担2个职责：存储数据，遍历数据。我们系统一般都会存在一些类，这些类的主要作用就是内部有个聚合对象（就是一堆对象，可能是list，set，map各种形式），对外我们可以存储和访问这些数据。正常思路上，这很简单，…</p>
<h4 id="【设计模式】解释器模式（2020-08-26-17-43-35-阅读-74-评论-0）"><a href="#【设计模式】解释器模式（2020-08-26-17-43-35-阅读-74-评论-0）" class="headerlink" title="【设计模式】解释器模式（2020-08-26 17:43:35 | 阅读 74 | 评论 0）"></a><a href="https://juejin.cn/post/6865225903312470029">【设计模式】解释器模式</a>（2020-08-26 17:43:35 | 阅读 74 | 评论 0）</h4><p>本文主要介绍解释器模式的概念和用法。 类似于于Java，Cpp这类的语言，他们无法处理类似1+2-3这种语句的直接计算，但是如果我们需要这样的功能，该怎么实现呢？这就是需要解释器模式。这是一个比较复杂同时也相对比较冷门的设计模式，实际应用中很少，因为一般涉及到解释器模式的项目应…</p>
<h4 id="【设计模式】命令模式（2020-08-25-14-04-35-阅读-85-评论-0）"><a href="#【设计模式】命令模式（2020-08-25-14-04-35-阅读-85-评论-0）" class="headerlink" title="【设计模式】命令模式（2020-08-25 14:04:35 | 阅读 85 | 评论 0）"></a><a href="https://juejin.cn/post/6864798514921897991">【设计模式】命令模式</a>（2020-08-25 14:04:35 | 阅读 85 | 评论 0）</h4><p>本文主要介绍命令模式的概念和用法，以及一些针对特定需要的变种形式。 在面向对象的程序中，调用的过程即耦合的过程，这不可避免。但是存在特殊的情况，调用方（我们称为请求者）和被调方（称为接收者）并不是调用关系很明确！又或者说一个请求者对应多个接收者，并且需要根据不同的环境选择不同的…</p>
<h4 id="【设计模式】责任链模式（2020-08-24-13-04-57-阅读-177-评论-0）"><a href="#【设计模式】责任链模式（2020-08-24-13-04-57-阅读-177-评论-0）" class="headerlink" title="【设计模式】责任链模式（2020-08-24 13:04:57 | 阅读 177 | 评论 0）"></a><a href="https://juejin.cn/post/6864412005626085389">【设计模式】责任链模式</a>（2020-08-24 13:04:57 | 阅读 177 | 评论 0）</h4><p>本文主要介绍责任链模式的概念及用法。 这个模式的应用场景也很多，最常见的就是一个审批流程：一个事件触发了需要一级一级的往下传递到对应的人进行处理的。对于这种审批流程最糟糕的写法就是在一个类中使用很长的if-else判断链来进行判断。这种写法缺点很多： 类职责过重，所有的审批流程…</p>
<h4 id="【设计模式】享元模式（2020-08-21-17-18-50-阅读-122-评论-0）"><a href="#【设计模式】享元模式（2020-08-21-17-18-50-阅读-122-评论-0）" class="headerlink" title="【设计模式】享元模式（2020-08-21 17:18:50 | 阅读 122 | 评论 0）"></a><a href="https://juejin.cn/post/6863364278288646152">【设计模式】享元模式</a>（2020-08-21 17:18:50 | 阅读 122 | 评论 0）</h4><p>本文主要介绍享元模式概念和用法，以及有状态享元模式，复合享元模式。 享元模式算是一个比较复杂的模式。在一些系统中，可能会需要大量的对象。比如游戏中的小兵，围棋系统中的黑子白子，如果我们每需要一个这样的对象的时候都去new一个，那么系统会创建大量的对象。这会加重系统的负担，如果是…</p>
<h4 id="【设计模式】外观模式（2020-08-21-11-10-56-阅读-538-评论-0）"><a href="#【设计模式】外观模式（2020-08-21-11-10-56-阅读-538-评论-0）" class="headerlink" title="【设计模式】外观模式（2020-08-21 11:10:56 | 阅读 538 | 评论 0）"></a><a href="https://juejin.cn/post/6863269485147914247">【设计模式】外观模式</a>（2020-08-21 11:10:56 | 阅读 538 | 评论 0）</h4><p>本文主要介绍外观模式及其抽象外观的原理和实现。 首先，使用外观模式之前就已经拥有一个很好的起点，系统业务中某些模块已经封装好了，而且职责单一。但是最终使用避免不了模块与模块，类与类之间的交互。这种交互该如何优化？就是外观模式要解决的。 书上举了一个例子，系统中有三个子模块：1.…</p>
<h4 id="【设计模式】装饰模式（2020-08-20-17-04-58-阅读-117-评论-0）"><a href="#【设计模式】装饰模式（2020-08-20-17-04-58-阅读-117-评论-0）" class="headerlink" title="【设计模式】装饰模式（2020-08-20 17:04:58 | 阅读 117 | 评论 0）"></a><a href="https://juejin.cn/post/6862989604983832584">【设计模式】装饰模式</a>（2020-08-20 17:04:58 | 阅读 117 | 评论 0）</h4><p>本文主要介绍：装饰模式概念和使用，以及对应的透明和半透明形式概念。 假设我们有一堆的类，这些类我们需要为他扩充一些功能。比如在执行该类的方法前或者后增加一些逻辑，该怎么做？相信你一定就已经能想到了装饰模式的用法！但是我们还是要说说最笨的方法： 最糟糕的设计就是，我们创建一个新的…</p>
<h4 id="【设计模式】组合模式（2020-08-19-14-09-32-阅读-820-评论-0）"><a href="#【设计模式】组合模式（2020-08-19-14-09-32-阅读-820-评论-0）" class="headerlink" title="【设计模式】组合模式（2020-08-19 14:09:32 | 阅读 820 | 评论 0）"></a><a href="https://juejin.cn/post/6862572997665013768">【设计模式】组合模式</a>（2020-08-19 14:09:32 | 阅读 820 | 评论 0）</h4><p>本文主要介绍：组合模式原理和用法，以及组合模式的透明和安全实现。 在书中给了一个案例：我们对给定的文件夹进行杀毒。文件夹和和子文件夹都需要递归进行查杀，并且需要依据文件是图片还是文本需要采用不同的查杀方式。 这是一个比较常见的业务场景。相当于我们要递归遍历一个树形结构，但是这个…</p>
<h4 id="【设计模式】桥接模式（2020-08-18-13-09-59-阅读-1032-评论-0）"><a href="#【设计模式】桥接模式（2020-08-18-13-09-59-阅读-1032-评论-0）" class="headerlink" title="【设计模式】桥接模式（2020-08-18 13:09:59 | 阅读 1032 | 评论 0）"></a><a href="https://juejin.cn/post/6862186471152877575">【设计模式】桥接模式</a>（2020-08-18 13:09:59 | 阅读 1032 | 评论 0）</h4><p>本文主要介绍：桥接模式概念和用法。 生活中，我们如果一个笔有三种型号：大，中，小。颜色一共有M种。如果需要所有型号都有相对应的颜色，那么就需要3*M只笔。但是如果我们转换一下：M种颜色代表M种墨水，笔的三种型号就对应三支笔，那么只需要3+M个，然后组合就可以得到相同的结果，这种…</p>
<h4 id="【设计模式】代理模式（2020-08-14-23-56-31-阅读-143-评论-0）"><a href="#【设计模式】代理模式（2020-08-14-23-56-31-阅读-143-评论-0）" class="headerlink" title="【设计模式】代理模式（2020-08-14 23:56:31 | 阅读 143 | 评论 0）"></a><a href="https://juejin.cn/post/6860867600298016781">【设计模式】代理模式</a>（2020-08-14 23:56:31 | 阅读 143 | 评论 0）</h4><p>本文主要介绍：通用的代理模式（即静态代理），Java动态代理，CGLib动态代理。 在某些场景下，处于某些原因，一个系统模块不希望或者不能直接访问另一个模块。比如现有的项目下，已经有了一个接口，但是他只提供了服务。在后续的开发中，发现有一些其他的模块需要调用它，但是需要对这个接…</p>
<h4 id="【设计模式】适配器模式（2020-08-06-21-51-48-阅读-101-评论-0）"><a href="#【设计模式】适配器模式（2020-08-06-21-51-48-阅读-101-评论-0）" class="headerlink" title="【设计模式】适配器模式（2020-08-06 21:51:48 | 阅读 101 | 评论 0）"></a><a href="https://juejin.cn/post/6857866397591044103">【设计模式】适配器模式</a>（2020-08-06 21:51:48 | 阅读 101 | 评论 0）</h4><p>本文主要介绍：类适配器模式，双向适配器模式，缺省适配器模式。 在我们生活中就存在着很多适配器模式，比如电源适配器，最新的苹果耳机接口（共用充电口的那个），插座适配器。这些都是因为我们现有的一些物件和外界提供的物件无法正确匹配，当需要能使用对方的时候，就需要一个中间的适配器来适配…</p>
<h4 id="【设计模式】建造者模式（2020-08-04-17-57-19-阅读-480-评论-0）"><a href="#【设计模式】建造者模式（2020-08-04-17-57-19-阅读-480-评论-0）" class="headerlink" title="【设计模式】建造者模式（2020-08-04 17:57:19 | 阅读 480 | 评论 0）"></a><a href="https://juejin.cn/post/6857065575815446536">【设计模式】建造者模式</a>（2020-08-04 17:57:19 | 阅读 480 | 评论 0）</h4><p>建造者模式主要针对复杂对象的创建，是一种比较复杂的对象创建型模式。本文主要介绍：建造者模式带Director实现，无Director实现，Lombok实现、 我们为什么要有建造者模式呢？在我们项目中可能存在一些比较复杂的对象的创建，比如一个对象里面组合了大量的其他的对象，如果将…</p>
<h4 id="【设计模式】原型模式（2020-07-31-18-08-45-阅读-98-评论-0）"><a href="#【设计模式】原型模式（2020-07-31-18-08-45-阅读-98-评论-0）" class="headerlink" title="【设计模式】原型模式（2020-07-31 18:08:45 | 阅读 98 | 评论 0）"></a><a href="https://juejin.cn/post/6855583870277189639">【设计模式】原型模式</a>（2020-07-31 18:08:45 | 阅读 98 | 评论 0）</h4><p>又是一个相对简单的模式，原型模式属于对象创建型模式。他主要作用就是通过一个原型对象克隆出多个一模一样的对象。 在我个人看来，设计模式作用方面可以分为两类：一类是用来优化代码结构的，比如系统解耦，让系统可扩展等等。另一类的模式对系统结构并无帮助，他不是结构型的，而是功能型的，就像…</p>
<h4 id="【设计模式】工厂模式（2020-07-31-00-58-45-阅读-107-评论-0）"><a href="#【设计模式】工厂模式（2020-07-31-00-58-45-阅读-107-评论-0）" class="headerlink" title="【设计模式】工厂模式（2020-07-31 00:58:45 | 阅读 107 | 评论 0）"></a><a href="https://juejin.cn/post/6855315314671812621">【设计模式】工厂模式</a>（2020-07-31 00:58:45 | 阅读 107 | 评论 0）</h4><p>通常我们说的工厂模式是指工厂方法模式。工厂模式的目的是将对象的创建和使用分离，用来移除一些类创建对象 和对象操作行为之间的耦合，让客户端类不创建对象交给工厂来创建对象。如果一个类没有太多变数，构造也简单就不要使用工厂类，不然只会导致工厂泛滥。 工厂模式是一种创建型模式。 开发中…</p>
<h4 id="【设计模式】单例模式（2020-07-30-00-25-33-阅读-110-评论-0）"><a href="#【设计模式】单例模式（2020-07-30-00-25-33-阅读-110-评论-0）" class="headerlink" title="【设计模式】单例模式（2020-07-30 00:25:33 | 阅读 110 | 评论 0）"></a><a href="https://juejin.cn/post/6855129007667544072">【设计模式】单例模式</a>（2020-07-30 00:25:33 | 阅读 110 | 评论 0）</h4><p>单例模式属于创建型模式。它应该是接触到的各种模式中最简单的，也是最普遍能见到的了。类似于Spring等很多框架里面都大量的采用了单例模式。本文将介绍所有网络上流传的单例模式的各种写法，如有不足欢迎补充！ 在某些情况下，我们需要系统中的某些对象，在全局只有唯一的存在，就是整个程序…</p>
<h4 id="【Java】Java中的finalize-方法（2020-07-23-18-49-02-阅读-1019-评论-0）"><a href="#【Java】Java中的finalize-方法（2020-07-23-18-49-02-阅读-1019-评论-0）" class="headerlink" title="【Java】Java中的finalize()方法（2020-07-23 18:49:02 | 阅读 1019 | 评论 0）"></a><a href="https://juejin.cn/post/6854573216900317198">【Java】Java中的finalize()方法</a>（2020-07-23 18:49:02 | 阅读 1019 | 评论 0）</h4><p>Java的垃圾回收器只会释放由我们new出来的内存堆块，那些不是由new出来的“特殊内存”，垃圾回收器是不会管理的。 所谓的特殊内存指通过JNI用C&#x2F;C++向系统申请的内存，这些内存如果不手动去清除就会一直占据在内存中。 而且，垃圾回收本身就有开销，所以虚拟机不会经常GC，只有…</p>
<h4 id="【Java】-lt-extend-E-gt-和-lt-super-E-gt-深入理解（2020-07-23-18-40-29-阅读-1167-评论-0）"><a href="#【Java】-lt-extend-E-gt-和-lt-super-E-gt-深入理解（2020-07-23-18-40-29-阅读-1167-评论-0）" class="headerlink" title="【Java】&lt;? extend E&gt; 和 &lt;? super E&gt; 深入理解（2020-07-23 18:40:29 | 阅读 1167 | 评论 0）"></a><a href="https://juejin.cn/post/6854573216896303117">【Java】&lt;? extend E&gt; 和 &lt;? super E&gt; 深入理解</a>（2020-07-23 18:40:29 | 阅读 1167 | 评论 0）</h4><p>Java使用 “?” 在泛型参数中做通配符，作用在于：当前你不知道指定该容器是什么类型，你可以是?占位，表明将来在使用的时候你再指明类型去使用。 我起初最疑惑的地方是编译器如何知道对应的通配类型可以存放那些数据的。 一定谨记： 编译器使用list的时候，只知道list的泛型参数…</p>
<h4 id="【Java】ConcurrentHashMap源码分析（2020-07-23-18-37-09-阅读-442-评论-0）"><a href="#【Java】ConcurrentHashMap源码分析（2020-07-23-18-37-09-阅读-442-评论-0）" class="headerlink" title="【Java】ConcurrentHashMap源码分析（2020-07-23 18:37:09 | 阅读 442 | 评论 0）"></a><a href="https://juejin.cn/post/6854573216896122893">【Java】ConcurrentHashMap源码分析</a>（2020-07-23 18:37:09 | 阅读 442 | 评论 0）</h4><p>JDK中提供了HashTable和ConcurrentHashMap两个类面向并发情况下使用HashMap的结构（或者使用Collections提供的synchronizedMap方法）。其中HashTable是通过对关键的操作全部加上synchronize同步锁来解决并发问题…</p>
<h4 id="【Java】HashMap源码分析（2020-07-23-18-29-11-阅读-460-评论-0）"><a href="#【Java】HashMap源码分析（2020-07-23-18-29-11-阅读-460-评论-0）" class="headerlink" title="【Java】HashMap源码分析（2020-07-23 18:29:11 | 阅读 460 | 评论 0）"></a><a href="https://juejin.cn/post/6854573216887734286">【Java】HashMap源码分析</a>（2020-07-23 18:29:11 | 阅读 460 | 评论 0）</h4><p>HashMap虽然常用，但是内部隐藏了很多实现细节，有太多值得推敲的东西，这里尽量去收录HashMap所有涉及的相关知识点。 先从数据结构说起，HashMap对照的是数据结构中的散列表结构。在数据结构中有一种结构叫字典。有的书上定义：“以集合为基础的一些元素的集合，每个元素都有…</p>
<h4 id="【Java】Java程序运行和对象创建过程简述（2020-07-23-18-18-25-阅读-150-评论-0）"><a href="#【Java】Java程序运行和对象创建过程简述（2020-07-23-18-18-25-阅读-150-评论-0）" class="headerlink" title="【Java】Java程序运行和对象创建过程简述（2020-07-23 18:18:25 | 阅读 150 | 评论 0）"></a><a href="https://juejin.cn/post/6854573216971620366">【Java】Java程序运行和对象创建过程简述</a>（2020-07-23 18:18:25 | 阅读 150 | 评论 0）</h4><p>Java中一个对象创建分为两个步骤： 加载类，创建对象。 加载类是将所写的程序.java文件编译生成的.class文件加载到内存中，保证了对象创建的预置环境。类加载完毕后才可以创建该类的对象。 当开始运行一个类，虚拟机首先试图访问指定启动类的 .main() 方法，加载该类的 …</p>
<h4 id="【Java】HashMap的负载因子为什么是0-75（2020-07-23-18-16-07-阅读-1329-评论-1）"><a href="#【Java】HashMap的负载因子为什么是0-75（2020-07-23-18-16-07-阅读-1329-评论-1）" class="headerlink" title="【Java】HashMap的负载因子为什么是0.75（2020-07-23 18:16:07 | 阅读 1329 | 评论 1）"></a><a href="https://juejin.cn/post/6854573216862568456">【Java】HashMap的负载因子为什么是0.75</a>（2020-07-23 18:16:07 | 阅读 1329 | 评论 1）</h4><p>在看hashmap源码的时候，最让我困惑的地方就是这里。相信很多人也有过这样的问题，相信很多人和我一样也是网上百度了一通，相信很多人和我一样百度，google一通后，答案就那么几个然后就默认了是对的了，但是实际上还是没有懵逼的以为懂了。这篇文章就来聊聊这0.75。 大概意思就是…</p>
<h4 id="【PaperReading】Bigtable（个人翻译）（2020-07-20-23-39-03-阅读-338-评论-0）"><a href="#【PaperReading】Bigtable（个人翻译）（2020-07-20-23-39-03-阅读-338-评论-0）" class="headerlink" title="【PaperReading】Bigtable（个人翻译）（2020-07-20 23:39:03 | 阅读 338 | 评论 0）"></a><a href="https://juejin.cn/post/6854573212781510663">【PaperReading】Bigtable（个人翻译）</a>（2020-07-20 23:39:03 | 阅读 338 | 评论 0）</h4><p>HBase的前身。 Fay Chang, Jeffrey Dean, Sanjay Ghemawat, Wilson C. Hsieh, Deborah A. Wallach Mike Burrows, Tushar Chandra, Andrew Fikes, Robert …</p>
<h4 id="【PaperReading】MapReduce（个人翻译）（2020-07-20-23-33-50-阅读-1354-评论-0）"><a href="#【PaperReading】MapReduce（个人翻译）（2020-07-20-23-33-50-阅读-1354-评论-0）" class="headerlink" title="【PaperReading】MapReduce（个人翻译）（2020-07-20 23:33:50 | 阅读 1354 | 评论 0）"></a><a href="https://juejin.cn/post/6854573212768927758">【PaperReading】MapReduce（个人翻译）</a>（2020-07-20 23:33:50 | 阅读 1354 | 评论 0）</h4><p>也是大数据最重要的一个数据处理方案。 MapReduce准确的来说应该是一个编程模型，或者说是一个用来处理和生产大量数据集的相关实现。用户通过指定一个map函数来处理一个K&#x2F;V键值对，这个键值对会被map生成一系列的中间键值对集。通过reduce函数，我们再将那些相同的中间ke…</p>
<h4 id="【PaperReading】The-Google-File-System（个人翻译）（2020-07-20-23-22-19-阅读-1588-评论-0）"><a href="#【PaperReading】The-Google-File-System（个人翻译）（2020-07-20-23-22-19-阅读-1588-评论-0）" class="headerlink" title="【PaperReading】The Google File System（个人翻译）（2020-07-20 23:22:19 | 阅读 1588 | 评论 0）"></a><a href="https://juejin.cn/post/6854573212761194510">【PaperReading】The Google File System（个人翻译）</a>（2020-07-20 23:22:19 | 阅读 1588 | 评论 0）</h4><p>该paper是2003年Google发表在SOSP（Symposium on Operating Systems Principles-计算机系统领域的顶会）的论文《The Google File System》个人翻译。作为Hadoop时代的三架马车之一，对当前分布式系统诸多…</p>
</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js?v=1"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-160006603-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-160006603-1');</script></html>